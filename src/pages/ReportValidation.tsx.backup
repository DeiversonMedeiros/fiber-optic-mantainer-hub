import React, { useState, useMemo, useEffect } from 'react';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Badge } from '@/components/ui/badge';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogTrigger, DialogDescription } from '@/components/ui/dialog';
import { Collapsible, CollapsibleContent, CollapsibleTrigger } from '@/components/ui/collapsible';
import { CheckCircle, XCircle, Edit, AlertTriangle, DollarSign, Trash2, ChevronDown, ChevronRight, Filter, FileText, ZoomIn, History, Clock, X } from 'lucide-react';
import { supabase } from '@/integrations/supabase/client';
import { useAuth } from '@/hooks/useAuth';
import { useToast } from '@/hooks/use-toast';
import { useDebounce } from '@/hooks/use-debounce';
import { ChecklistFormSection } from '@/components/reports/ChecklistFormSection';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table';
import { Sheet, SheetContent, SheetHeader, SheetTitle, SheetTrigger } from '@/components/ui/sheet';


import { exportToCSV } from "@/utils/csvExport";

import LoadingSpinner from '@/components/ui/LoadingSpinner';

// Tipos para otimização
interface ValidationReportsResponse {
  data: any[];
  total: number;
  page: number;
  pageSize: number;
}

const ReportValidation = () => {
  const { user } = useAuth();
  const { toast } = useToast();
  const queryClient = useQueryClient();
  const [expandedCards, setExpandedCards] = useState<Set<string>>(new Set());
  const [selectedTechnician, setSelectedTechnician] = useState<string>('');
  const [filters, setFilters] = useState({
    technician: 'all',
    status: 'all',
    serviceType: 'all',
    serviceNumber: '',
    reportNumber: '',
    userClass: 'all',
    startDate: '',
    endDate: '',
    dynamicField: '', // NOVO FILTRO
  });

  // Estado separado para o input do número do serviço para evitar perda de foco
  const [serviceNumberInput, setServiceNumberInput] = useState('');
  
  // Estado separado para o input do número do relatório para evitar perda de foco
  const [reportNumberInput, setReportNumberInput] = useState('');
  
  // Estado separado para o input de campos dinâmicos para evitar perda de foco
  const [dynamicFieldInput, setDynamicFieldInput] = useState('');
  
  // Aplicar debounce de 500ms no serviceNumber para evitar consultas excessivas
  const debouncedServiceNumber = useDebounce(serviceNumberInput, 500);
  
  // Aplicar debounce de 500ms no reportNumber para evitar consultas excessivas
  const debouncedReportNumber = useDebounce(reportNumberInput, 500);
  
  // Aplicar debounce de 500ms no dynamicField para evitar consultas excessivas
  const debouncedDynamicField = useDebounce(dynamicFieldInput, 500);

  // Sincronizar valor com debounce com o estado de filtros
  useEffect(() => {
    setFilters(prev => ({ ...prev, serviceNumber: debouncedServiceNumber }));
  }, [debouncedServiceNumber]);
  
  // Sincronizar valor com debounce com o estado de filtros
  useEffect(() => {
    setFilters(prev => ({ ...prev, reportNumber: debouncedReportNumber }));
  }, [debouncedReportNumber]);
  
  // Sincronizar valor com debounce com o estado de filtros
  useEffect(() => {
    setFilters(prev => ({ ...prev, dynamicField: debouncedDynamicField }));
  }, [debouncedDynamicField]);

  const [editReportId, setEditReportId] = useState<string | null>(null);
  const [editTitle, setEditTitle] = React.useState('');
  const [editDescription, setEditDescription] = React.useState('');
  const [isSaving, setIsSaving] = React.useState(false);
  const [editFormData, setEditFormData] = React.useState<Record<string, any>>({});
  const [editChecklist, setEditChecklist] = React.useState<any[]>([]);
  const [editAttachments, setEditAttachments] = React.useState<any[]>([]);
  const [editFilesToUpload, setEditFilesToUpload] = React.useState<File[]>([]);
  const [editUploadError, setEditUploadError] = React.useState<string | null>(null);

  // Estados para paginação otimizada
  const [currentPage, setCurrentPage] = useState(1);
  const [pageSize, setPageSize] = useState(20);

  // 1. Adicionar estado para modal de pendência
  const [pendingModalOpen, setPendingModalOpen] = React.useState<string | null>(null); // id do relatório
  const [pendingReason, setPendingReason] = React.useState('');
  const [pendingNotes, setPendingNotes] = React.useState('');
  const pendingOptions = [
    'Serviço a Mais',
    'Serviço Incorreto',
    'Falta Serviço',
    'Falta Material',
    'Material a Mais',
    'Material Incorreto',
    'Foto sem Localização',
    'Foto fora Padrão',
    'Sem Foto',
    'Falta Foto Caixa Fechada',
    'Falta Foto Caixa Aberta',
    'Falta As built',
    'Falta Croqui',
    'Falta Adequar',
    'Falta foto do sir',
    'Falta Coordenadas',
    'Outros',
  ];

  // Hooks para histórico de atividades (no topo do componente)
  const [activities, setActivities] = useState<Record<string, any[]>>({});
  const [loadingActivities, setLoadingActivities] = useState<Record<string, boolean>>({});
  // Adicionar estado para map de nomes de usuários
  const [userNames, setUserNames] = useState<Record<string, string>>({});
  const [assignedNames, setAssignedNames] = useState<Record<string, string>>({});
  const [managerNames, setManagerNames] = useState<Record<string, string>>({});

  async function fetchActivities(reportId: string) {
    setLoadingActivities((prev) => ({ ...prev, [reportId]: true }));
    const { data, error } = await supabase
      .from('activities')
      .select('*')
      .eq('entity_type', 'report')
      .eq('entity_id', reportId)
      .order('created_at', { ascending: false });
    if (!error) {
      setActivities((prev) => ({ ...prev, [reportId]: data }));
      // Buscar nomes dos usuários únicos
      const userIds = Array.from(new Set((data || []).map((a: any) => a.user_id).filter(Boolean)));
      if (userIds.length > 0) {
        const { data: profiles, error: errorProfiles } = await supabase
          .from('profiles')
          .select('id, name')
          .in('id', userIds);
        if (profiles) {
          const map: Record<string, string> = {};
          profiles.forEach((p: any) => { map[p.id] = p.name; });
          setUserNames((prev) => ({ ...prev, ...map }));
        }
      }
    }
    setLoadingActivities((prev) => ({ ...prev, [reportId]: false }));
  }

  // --- QUERY OTIMIZADA COM PAGINAÇÃO NO BACKEND ---
  const { data: reportsResponse, isLoading, error: reportsError } = useQuery<ValidationReportsResponse>({
    queryKey: ['validation-reports', filters, currentPage, pageSize],
    queryFn: async () => {
      try {
        const offset = (currentPage - 1) * pageSize;
        
        // Query SIMPLIFICADA para eliminar erro 400
        let query = supabase
          .from('reports')
          .select(`
            id, title, description, status, created_at, updated_at, 
            numero_servico, pending_reason, pending_notes, assigned_to, 
            attachments, form_data, checklist_data, report_number, parent_report_id,
            validated_by, validated_at, technician_id, template_id
          `, { count: 'exact' })
          .neq('template_id', '4b45c601-e5b7-4a33-98f9-1769aad319e9')
          .order('created_at', { ascending: false })
          .range(offset, offset + pageSize - 1);
        
        // Aplicar filtros no backend com validação
        console.log('🔍 Filtros aplicados:', filters);
        
        if (filters.technician && filters.technician !== 'all') {
          query = query.eq('technician_id', filters.technician);
          console.log('🔍 Filtro técnico aplicado:', filters.technician);
        }
        if (filters.status && filters.status !== 'all') {
          query = query.eq('status', filters.status as any);
          console.log('🔍 Filtro status aplicado:', filters.status);
        }
        if (filters.serviceNumber && filters.serviceNumber.trim()) {
          query = query.ilike('numero_servico', `%${filters.serviceNumber.trim()}%`);
          console.log('🔍 Filtro número do serviço aplicado:', filters.serviceNumber);
        }
        if (filters.reportNumber && filters.reportNumber.trim()) {
          // Remover "REL-" se o usuário digitou
          const cleanReportNumber = filters.reportNumber.trim().replace(/^REL-?/i, '');
          if (cleanReportNumber) {
            query = query.eq('report_number', parseInt(cleanReportNumber));
            console.log('🔍 Filtro número do relatório aplicado:', cleanReportNumber);
          }
        }
        if (filters.startDate && filters.startDate.trim()) {
          query = query.gte('created_at', filters.startDate);
          console.log('🔍 Filtro data inicial aplicado:', filters.startDate);
        }
        if (filters.endDate && filters.endDate.trim()) {
          query = query.lte('created_at', filters.endDate + 'T23:59:59');
          console.log('🔍 Filtro data final aplicado:', filters.endDate);
        }
        
        // NOVO: Filtro para campos dinâmicos - VERSÃO MELHORADA
        if (filters.dynamicField && filters.dynamicField.trim()) {
          const searchTerm = filters.dynamicField.trim();
          console.log('🔍 Aplicando filtro de campos dinâmicos:', searchTerm);
          
          try {
            // Abordagem MELHORADA: Buscar em campos básicos E form_data simultaneamente
            console.log('🔍 Buscando em campos básicos e form_data...');
            
            // Busca principal: campos básicos
            query = query.or(`title.ilike.%${searchTerm}%,description.ilike.%${searchTerm}%,numero_servico.ilike.%${searchTerm}%`);
            
            // Log da query para debug
            console.log('🔍 Query após filtro de campos dinâmicos:', query);
            
          } catch (error) {
            console.error('❌ Erro ao aplicar filtro de campos dinâmicos:', error);
            // Fallback: buscar apenas em campos básicos
            query = query.or(`title.ilike.%${searchTerm}%,description.ilike.%${searchTerm}%`);
          }
        }
        
        // Filtro por classe de usuário
        if (filters.userClass && filters.userClass !== 'all') {
          // Buscar técnicos da classe selecionada
          const { data: techniciansFromClass } = await supabase
            .from('profiles')
            .select('id')
            .eq('user_class_id', filters.userClass)
            .eq('is_active', true);
          
          if (techniciansFromClass && techniciansFromClass.length > 0) {
            const technicianIds = techniciansFromClass.map(t => t.id);
            query = query.in('technician_id', technicianIds);
          } else {
            // Se não há técnicos nesta classe, retornar vazio
            query = query.eq('technician_id', 'no-technicians-found');
          }
        }
        
        const { data, count, error } = await query;
        
        if (error) {
          console.error('❌ Erro na query principal:', error);
          console.error('❌ Detalhes do erro:', {
            message: error.message,
            details: error.details,
            hint: error.hint,
            code: error.code
          });
          throw error;
        }
        
        console.log('✅ Query executada com sucesso');
        console.log('📊 Resultados encontrados:', count || 0);
        console.log('📋 Dados retornados:', data?.length || 0);
        
        // Busca adicional em form_data se o filtro de campos dinâmicos foi aplicado
        if (filters.dynamicField && filters.dynamicField.trim() && data && data.length === 0) {
          console.log('🔍 Nenhum resultado encontrado, tentando busca alternativa em form_data...');
          const searchTerm = filters.dynamicField.trim();
          
          // Logs para debug
          console.log('🔍 Parâmetros da busca alternativa:');
          console.log('  - searchTerm:', searchTerm);
          console.log('  - offset:', offset);
          console.log('  - pageSize:', pageSize);
          console.log('  - currentPage:', currentPage);
          
          try {
            // Busca alternativa: buscar apenas em form_data
            console.log('🔍 Construindo query alternativa...');
            
            const formDataQuery = supabase
              .from('reports')
              .select(`
                id, title, description, status, created_at, updated_at, 
                numero_servico, pending_reason, pending_notes, assigned_to, 
                attachments, form_data, checklist_data, report_number, parent_report_id,
                validated_by, validated_at, technician_id, template_id
              `, { count: 'exact' })
              .neq('template_id', '4b45c601-e5b7-4a33-98f9-1769aad319e9');
            
            console.log('🔍 Query base construída:', formDataQuery);
            
            // Aplicar filtro de busca em form_data
            const queryWithFilter = formDataQuery.ilike('form_data::text', `%${searchTerm}%`);
            console.log('🔍 Query com filtro aplicado:', queryWithFilter);
            
            // Aplicar ordenação
            const queryWithOrder = queryWithFilter.order('created_at', { ascending: false });
            console.log('🔍 Query com ordenação:', queryWithOrder);
            
            // Aplicar paginação
            const finalQuery = queryWithOrder.range(offset, offset + pageSize - 1);
            console.log('🔍 Query final com paginação:', finalQuery);
            console.log('🔍 Parâmetros de paginação - offset:', offset, 'limit:', pageSize);
            
            const { data: formDataResults, error: formDataError } = await finalQuery;
            
            if (formDataError) {
              console.error('❌ Erro na busca alternativa:', formDataError);
              console.error('❌ Detalhes do erro:');
              console.error('  - Message:', formDataError.message);
              console.error('  - Code:', formDataError.code);
              console.error('  - Details:', formDataError.details);
              console.error('  - Hint:', formDataError.hint);
            } else {
              console.log('✅ Busca alternativa encontrou:', formDataResults?.length || 0, 'resultados');
              if (formDataResults && formDataResults.length > 0) {
                // Usar os resultados da busca alternativa
                const finalData = formDataResults;
                const finalCount = formDataResults.length;
                
                // Processar os dados usando a lógica existente
                const reports = finalData || [];
                if (reports.length > 0) {
                  // Buscar técnicos únicos
                  const technicianIds = [...new Set(reports.map((r: any) => r.technician_id).filter(Boolean))];
                  const templateIds = [...new Set(reports.map((r: any) => r.template_id).filter(Boolean))];
                  
                  // Buscar dados dos técnicos
                  let techniciansData: any[] = [];
                  if (technicianIds.length > 0) {
                    const { data: techData } = await supabase
                      .from('profiles')
                      .select('id, name, user_class:user_classes(id, name)')
                      .in('id', technicianIds);
                    techniciansData = techData || [];
                  }
                  
                  // Buscar dados dos templates
                  let templatesData: any[] = [];
                  if (templateIds.length > 0) {
                    const { data: tempData } = await supabase
                      .from('report_templates')
                      .select('*')
                      .in('id', templateIds);
                    templatesData = tempData || [];
                  }
                  
                  // Mapear dados para incluir relacionamentos
                  const reportsWithRelations = reports.map((report: any) => {
                    const technician = techniciansData.find(t => t.id === report.technician_id);
                    const template = templatesData.find(t => t.id === report.template_id);
                    
                    return {
                      ...report,
                      technician,
                      template
                    };
                  });
                  
                  return {
                    data: reportsWithRelations,
                    total: finalCount,
                    page: currentPage,
                    pageSize
                  };
                }
              }
            }
          } catch (altError) {
            console.error('❌ Erro na busca alternativa:', altError);
            console.error('❌ Tipo do erro:', typeof altError);
            console.error('❌ Stack trace:', altError instanceof Error ? altError.stack : 'N/A');
            console.error('❌ String do erro:', String(altError));
          }
        }
      
      // Buscar dados dos técnicos e templates separadamente para evitar erros de join
      const reports = data || [];
      if (reports.length > 0) {
        // Buscar técnicos únicos
        const technicianIds = [...new Set(reports.map((r: any) => r.technician_id).filter(Boolean))];
        const templateIds = [...new Set(reports.map((r: any) => r.template_id).filter(Boolean))];
        
        // Buscar dados dos técnicos
        let techniciansData: any[] = [];
        if (technicianIds.length > 0) {
          const { data: techData } = await supabase
            .from('profiles')
            .select('id, name, user_class:user_classes(id, name)')
            .in('id', technicianIds);
          techniciansData = techData || [];
        }
        
        // Buscar dados dos templates
        let templatesData: any[] = [];
        if (templateIds.length > 0) {
          const { data: tempData } = await supabase
            .from('report_templates')
            .select('*')
            .in('id', templateIds);
          templatesData = tempData || [];
        }
        
        // Mapear dados para incluir relacionamentos
        const reportsWithRelations = reports.map((report: any) => {
          const technician = techniciansData.find(t => t.id === report.technician_id);
          const template = templatesData.find(t => t.id === report.template_id);
          
          return {
            ...report,
            technician,
            template
          };
        });
        
        return {
          data: reportsWithRelations,
          total: count || 0,
          page: currentPage,
          pageSize
        };
      }
      
      return {
        data: reports,
        total: count || 0,
        page: currentPage,
        pageSize
      };
    } catch (error) {
      console.error('❌ Erro completo na query de relatórios:', error);
      console.error('❌ Stack trace:', error.stack);
      return {
        data: [],
        total: 0,
        page: currentPage,
        pageSize
      };
    }
    },
    staleTime: 2 * 60 * 1000, // 2 minutos
    gcTime: 5 * 60 * 1000,    // 5 minutos
    refetchOnWindowFocus: false,
    refetchOnMount: false,
  });

  // Extrair dados da resposta com verificação robusta
  const reports = useMemo(() => {
    return reportsResponse?.data || [];
  }, [reportsResponse?.data]);
  
  const totalReports = reportsResponse?.total || 0;
  const totalPages = Math.ceil(totalReports / pageSize);

  // Buscar técnicos para filtro - apenas técnicos ativos (otimizado com cache)
  const { data: technicians = [] } = useQuery({
    queryKey: ['technicians'],
    queryFn: async () => {
      const { data, error } = await supabase
        .from('profiles')
        .select('id, name')
        .eq('is_active', true)
        .eq('access_profile_id', '38a5d358-75d6-4ae6-a109-1456a7dba714')
        .order('name');
      if (error) throw error;
      return data;
    },
    staleTime: 10 * 60 * 1000, // 10 minutos
    gcTime: 30 * 60 * 1000,    // 30 minutos
    refetchOnWindowFocus: false,
    refetchOnMount: false,
  });

  // Buscar classes de usuário (otimizado com cache)
  const { data: userClasses = [] } = useQuery({
    queryKey: ['user-classes'],
    queryFn: async () => {
      const { data, error } = await supabase
        .from('user_classes')
        .select('*')
        .eq('is_active', true)
        .order('name');
      if (error) throw error;
      return data;
    },
    staleTime: 10 * 60 * 1000, // 10 minutos
    gcTime: 30 * 60 * 1000,    // 30 minutos
    refetchOnWindowFocus: false,
    refetchOnMount: false,
  });

  // Criar queryKey estável para adequação reports
  const adequacaoQueryKey = useMemo(() => {
    if (!reports || reports.length === 0) return ['adequacao-reports', 'empty'];
    const reportIds = reports.map((r: any) => r?.id).filter(Boolean).sort();
    return ['adequacao-reports', reportIds.join(',')];
  }, [reports]);

  // Buscar relatórios de adequação (que são filhos dos relatórios exibidos)
  const { data: adequacaoReports = {} } = useQuery({
    queryKey: adequacaoQueryKey,
    queryFn: async () => {
      try {
        if (!reports || reports.length === 0) return {};
        
        const reportIds = reports.map((r: any) => r?.id).filter(Boolean);
        if (reportIds.length === 0) return {};
      
      // Query SIMPLIFICADA para relatórios de adequação
      const { data, error } = await supabase
        .from('reports')
        .select(`
          id, title, description, status, created_at, updated_at, parent_report_id,
          attachments, form_data, checklist_data, technician_id, template_id
        `)
        .in('parent_report_id', reportIds)
        .order('created_at', { ascending: false });
      
      if (error) throw error;
      
      // Buscar dados dos técnicos e templates para adequação separadamente
      const adequacaoData = data || [];
      if (adequacaoData.length > 0) {
        const techIds = [...new Set(adequacaoData.map((r: any) => r.technician_id).filter(Boolean))];
        const tempIds = [...new Set(adequacaoData.map((r: any) => r.template_id).filter(Boolean))];
        
        // NOVO: Buscar dados dos relatórios principais (parent_report_id)
        const parentReportIds = [...new Set(adequacaoData.map((r: any) => r.parent_report_id).filter(Boolean))];
        
        let technicians: any[] = [];
        let templates: any[] = [];
        let parentReports: any[] = [];
        
        if (techIds.length > 0) {
          const { data: techData } = await supabase
            .from('profiles')
            .select('id, name')
            .in('id', techIds);
          technicians = techData || [];
        }
        
        if (tempIds.length > 0) {
          const { data: tempData } = await supabase
            .from('report_templates')
            .select('*')
            .in('id', tempIds);
          templates = tempData || [];
        }
        
        // NOVO: Buscar relatórios principais
        if (parentReportIds.length > 0) {
          const { data: parentData } = await supabase
            .from('reports')
            .select('id, title, report_number')
            .in('id', parentReportIds);
          parentReports = parentData || [];
        }
        
        // Mapear adequações com relacionamentos
        const adequacoesWithRelations = adequacaoData.map((adequacao: any) => {
          const technician = technicians.find(t => t.id === adequacao.technician_id);
          const template = templates.find(t => t.id === adequacao.template_id);
          const parentReport = parentReports.find(p => p.id === adequacao.parent_report_id);
          
          return {
            ...adequacao,
            technician,
            template,
            parentReport // NOVO: incluir dados do relatório principal
          };
        });
        
        // Organizar por parent_report_id
        const grouped: Record<string, any> = {};
        adequacoesWithRelations.forEach((adequacaoReport: any) => {
          if (adequacaoReport.parent_report_id) {
            grouped[adequacaoReport.parent_report_id] = adequacaoReport;
          }
        });
        
        return grouped;
      }
      
      return {};
      } catch (error) {
        console.error('Erro na query de adequação:', error);
        return {};
      }
    },
    enabled: !!reports && reports.length > 0 && !isLoading,
    staleTime: 5 * 60 * 1000, // 5 minutos
    gcTime: 10 * 60 * 1000,   // 10 minutos
    refetchOnWindowFocus: false,
    refetchOnMount: false,
  });

  // Criar queryKey estável para checklist items
  const checklistQueryKey = useMemo(() => {
    return [
      'report-checklist-items', 
      currentPage, 
      pageSize, 
      filters.technician, 
      filters.status,
      reports?.length || 0
    ];
  }, [currentPage, pageSize, filters.technician, filters.status, reports?.length]);

  // Buscar itens do checklist para todos os relatórios exibidos (otimizado)
  const { data: checklistItemsByReport = {} } = useQuery({
    queryKey: checklistQueryKey,
    queryFn: async () => {
      try {
        if (!reports || reports.length === 0) return {};
        
        const reportIds = reports.map((r: any) => r?.id).filter(Boolean);
        if (reportIds.length === 0) return {};
      // 1. Buscar todos os report_checklist_items
      const { data: checklistLinks, error: errorLinks } = await supabase
        .from('report_checklist_items')
        .select('report_id, checklist_item_id, quantity, notes')
        .in('report_id', reportIds);
      if (errorLinks) throw errorLinks;
      const checklistItemIds = [...new Set((checklistLinks || []).map((item: any) => item.checklist_item_id))];
      // 2. Buscar todos os checklist_items necessários
      const { data: checklistItems, error: errorItems } = await supabase
        .from('checklist_items')
        .select('id, name, category, standard_quantity')
        .in('id', checklistItemIds);
      if (errorItems) throw errorItems;
      const checklistItemMap: Record<string, any> = {};
      (checklistItems || []).forEach((item: any) => { checklistItemMap[item.id] = item; });
      // 3. Agrupar por report_id e adicionar nome
      const grouped: Record<string, any[]> = {};
      (checklistLinks || []).forEach((item: any) => {
        if (!grouped[item.report_id]) grouped[item.report_id] = [];
        grouped[item.report_id].push({
          ...item,
          name: checklistItemMap[item.checklist_item_id]?.name || '-',
          category: checklistItemMap[item.checklist_item_id]?.category || ''
        });
      });
      
      // 4. FALLBACK: Para relatórios que não têm dados na tabela report_checklist_items,
      // buscar do campo checklist_data
      const reportsWithoutChecklist = reports.filter((report: any) => 
        !grouped[report.id] || grouped[report.id].length === 0
      );
      
      for (const report of reportsWithoutChecklist) {
        if (Array.isArray(report.checklist_data) && report.checklist_data.length > 0) {
          if (!grouped[report.id]) grouped[report.id] = [];
          
          // Buscar nomes dos itens do checklist_data
          const checklistItemIdsFromData = [...new Set(
            report.checklist_data
              .filter((item: any) => item && typeof item === 'object' && 'id' in item)
              .map((item: any) => item.id)
              .filter((id: any) => typeof id === 'string')
          )];
          
          if (checklistItemIdsFromData.length > 0) {
            const { data: fallbackItems, error: fallbackError } = await supabase
              .from('checklist_items')
              .select('id, name, category, standard_quantity')
              .in('id', checklistItemIdsFromData as string[]);
            
            if (!fallbackError && fallbackItems) {
              const fallbackItemMap: Record<string, any> = {};
              fallbackItems.forEach((item: any) => { fallbackItemMap[item.id] = item; });
              
              report.checklist_data.forEach((item: any) => {
                if (item && typeof item === 'object' && 'id' in item) {
                  grouped[report.id].push({
                    report_id: report.id,
                    checklist_item_id: item.id,
                    quantity: item.quantity || 1,
                    notes: item.notes || '',
                    name: fallbackItemMap[item.id]?.name || item.name || '-',
                    category: fallbackItemMap[item.id]?.category || item.category || ''
                  });
                }
              });
            }
          }
        }
      }
      
      return grouped;
      } catch (error) {
        console.error('Erro na query de checklist items:', error);
        return {};
      }
    },
    enabled: reports.length > 0,
    staleTime: 5 * 60 * 1000, // 5 minutos
    gcTime: 10 * 60 * 1000,   // 10 minutos
    refetchOnWindowFocus: false,
    refetchOnMount: false,
  });

  // [ADICIONAR] Buscar todos os itens ativos do checklist (otimizado com cache)
  const { data: allChecklistItems = [] } = useQuery({
    queryKey: ['all-checklist-items'],
    queryFn: async () => {
      const { data, error } = await supabase
        .from('checklist_items')
        .select('*')
        .eq('is_active', true)
        .order('category', { ascending: true })
        .order('name', { ascending: true });
      if (error) throw error;
      return data;
    },
    staleTime: 10 * 60 * 1000, // 10 minutos
    gcTime: 30 * 60 * 1000,    // 30 minutos
    refetchOnWindowFocus: false,
    refetchOnMount: false,
  });

  // [ADICIONAR] Buscar dados do checklist do relatório sendo editado - DESABILITADO TEMPORARIAMENTE
  const editReportChecklistData: any[] = [];

  // Mutações para ações nos relatórios
  const updateStatusMutation = useMutation({
    mutationFn: async ({ reportId, status, assignedTo, pending_reason, pending_notes }: { reportId: string, status: string, assignedTo?: string, pending_reason?: string, pending_notes?: string }) => {
      const updateObj: any = { status };
      if (status === "em_adequacao" && assignedTo) {
        updateObj.assigned_to = assignedTo;
      }
      if (status === "validado") {
        updateObj.validated_by = user?.id;
        updateObj.validated_at = new Date().toISOString();
      }
      if (typeof status === 'string' && status === "faturado") {
        (updateObj as any).invoiced_at = new Date().toISOString();
      }
      if (status === "pendente") {
        updateObj.pending_reason = pending_reason;
        updateObj.pending_notes = pending_notes;
      }
      const { error } = await supabase
        .from('reports')
        .update(updateObj)
        .eq('id', reportId);
      if (error) throw error;
      // Registrar atividade
      await supabase.from('activities').insert([
        {
          user_id: user?.id,
          action: status,
          entity_type: 'report',
          entity_id: reportId,
          details: {
            assignedTo,
            pending_reason,
            pending_notes
          }
        }
      ]);
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['validation-reports'] });
      queryClient.invalidateQueries({ queryKey: ['adequacao-reports'] });
      queryClient.invalidateQueries({ queryKey: ['report-checklist-items'] });
      toast({
        title: "Status atualizado",
        description: "O status do relatório foi atualizado com sucesso.",
      });
    }
  });

  const deleteReportMutation = useMutation({
    mutationFn: async (reportId: string) => {
      const { error } = await supabase.from('reports').delete().eq('id', reportId);
      if (error) throw error;
      // Registrar atividade
      await supabase.from('activities').insert([
        {
          user_id: user?.id,
          action: 'deletar',
          entity_type: 'report',
          entity_id: reportId,
          details: {}
        }
      ]);
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['validation-reports'] });
      queryClient.invalidateQueries({ queryKey: ['adequacao-reports'] });
      toast({
        title: "Relatório deletado",
        description: "O relatório foi removido com sucesso.",
      });
    }
  });

  const getStatusColor = (status: string) => {
    const colors = {
      'nao_validado': 'bg-orange-100 text-orange-800',
      'validado': 'bg-green-100 text-green-800',
      'pendente': 'bg-red-100 text-red-800',
      'em_adequacao': 'bg-yellow-100 text-yellow-800',
      'faturado': 'bg-blue-100 text-blue-800',
      'sem_pendencia': 'bg-emerald-100 text-emerald-800',
      'adequado': 'bg-teal-100 text-teal-800',
    };
    return colors[status as keyof typeof colors] || 'bg-gray-100 text-gray-800';
  };

  const getStatusLabel = (status: string) => {
    const labels = {
      'nao_validado': 'Não Validado',
      'validado': 'Validado',
      'pendente': 'Pendente',
      'em_adequacao': 'Em adequação',
      'faturado': 'Faturado',
      'sem_pendencia': 'Sem pendência',
      'adequado': 'Adequado',
    };
    return labels[status as keyof typeof labels] || status;
  };

  const toggleCardExpansion = (reportId: string) => {
    const newExpanded = new Set(expandedCards);
    if (newExpanded.has(reportId)) {
      newExpanded.delete(reportId);
    } else {
      newExpanded.add(reportId);
    }
    setExpandedCards(newExpanded);
  };

  const handleStatusUpdate = (reportId: string, status: string, assignedTo?: string) => {
    updateStatusMutation.mutate({ reportId, status, assignedTo });
  };

  const handleDeleteReport = (reportId: string) => {
    if (window.confirm("Tem certeza que deseja deletar este relatório?")) {
      deleteReportMutation.mutate(reportId);
    }
  };

  // Funções para paginação
  const handlePageChange = (page: number) => {
    setCurrentPage(page);
    setExpandedCards(new Set()); // Reset expanded cards on page change
  };

  const handlePageSizeChange = (newPageSize: number) => {
    setPageSize(newPageSize);
    setCurrentPage(1); // Reset to first page
    setExpandedCards(new Set()); // Reset expanded cards
  };

  // Sincronizar campos ao abrir o modal - REMOVIDO PARA EVITAR LOOPS
  // Os campos serão sincronizados diretamente nos handlers

  const reportToEdit = editReportId ? reports.find(r => r.id === editReportId) : null;
  
  const template = reportToEdit?.template;

  const handleEditFieldChange = (fieldId: string, value: any) => {
    setEditFormData(prev => ({ ...prev, [fieldId]: value }));
  };

  // Função para sincronizar campos quando abrir modal de edição
  const handleOpenEditModal = (reportId: string) => {
    const reportToEdit = reports.find(r => r.id === reportId);
    if (reportToEdit) {
      setEditReportId(reportId);
      setEditTitle(reportToEdit.title || '');
      setEditDescription(reportToEdit.description || '');
      setEditFormData(
        typeof reportToEdit.form_data === 'object' && !Array.isArray(reportToEdit.form_data)
          ? reportToEdit.form_data
          : {}
      );
      setEditAttachments(
        Array.isArray(reportToEdit.attachments)
          ? reportToEdit.attachments
          : []
      );
      setEditFilesToUpload([]);
      setEditUploadError(null);
      
      // Sincronizar checklist do relatório
      if (Array.isArray(reportToEdit.checklist_data)) {
        setEditChecklist(reportToEdit.checklist_data);
      } else {
        setEditChecklist([]);
      }
    }
  };

  const handleEditChecklistChange = (selected: any[]) => {
    setEditChecklist(selected);
  };

  const handleEditFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    if (!e.target.files) return;
    const files = Array.from(e.target.files);
    // Limitar quantidade e tamanho
    const totalFiles = editAttachments.length + files.length;
    if (totalFiles > 10) {
      setEditUploadError('Máximo de 10 arquivos permitidos.');
      return;
    }
    for (const file of files) {
      if (file.size > 10 * 1024 * 1024) {
        setEditUploadError('Cada arquivo deve ter até 10MB.');
        return;
      }
    }
    setEditFilesToUpload(files);
    setEditUploadError(null);
  };

  const handleRemoveAttachment = (idx: number) => {
    setEditAttachments(prev => prev.filter((_, i) => i !== idx));
  };

  async function uploadEditFiles(files: File[], userId: string) {
    const uploaded = [];
    for (const file of files) {
      const timestamp = Date.now();
      const filePath = `reports/${userId}/${timestamp}_${file.name}`;
      const { data, error } = await supabase.storage
        .from('report-attachments')
        .upload(filePath, file, { upsert: false });
      if (error) throw error;
      const { data: publicUrl } = supabase.storage.from('report-attachments').getPublicUrl(filePath);
      uploaded.push({
        name: file.name,
        url: publicUrl.publicUrl,
        path: filePath,
        size: file.size,
        type: file.type
      });
    }
    return uploaded;
  }

  const handleEditSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsSaving(true);
    let newAttachments = [...editAttachments];
    try {
      if (editFilesToUpload.length > 0 && user) {
        const uploaded = await uploadEditFiles(editFilesToUpload, user.id);
        newAttachments = [...editAttachments, ...uploaded];
      }
      const { error } = await supabase
        .from('reports')
        .update({
          title: editTitle,
          description: editDescription,
          form_data: editFormData,
          checklist_data: editChecklist,
          attachments: newAttachments
        })
        .eq('id', editReportId);
      if (error) throw error;
      // Atualizar checklist relacional se necessário (exemplo simplificado)
      await supabase.from('report_checklist_items').delete().eq('report_id', editReportId);
      if (editChecklist.length > 0) {
        const checklistInserts = editChecklist.map((item: any) => ({
          report_id: editReportId,
          checklist_item_id: item.id,
          quantity: item.quantity,
          notes: item.notes
        }));
        await supabase.from('report_checklist_items').insert(checklistInserts);
      }
      // Registrar atividade de edição
      await supabase.from('activities').insert([
        {
          user_id: user?.id,
          action: 'editar',
          entity_type: 'report',
          entity_id: editReportId,
          details: {
            title: editTitle,
            description: editDescription,
            form_data: editFormData,
            checklist_data: editChecklist,
            attachments: newAttachments
          }
        }
      ]);
      queryClient.invalidateQueries({ queryKey: ['validation-reports'] });
      queryClient.invalidateQueries({ queryKey: ['adequacao-reports'] });
      queryClient.invalidateQueries({ queryKey: ['report-checklist-items'] });
      queryClient.invalidateQueries({ queryKey: ['edit-report-checklist'] });
      queryClient.invalidateQueries({ queryKey: ['all-checklist-items'] });
      setEditReportId(null);
      toast({ title: 'Relatório atualizado', description: 'As alterações foram salvas com sucesso.' });
    } catch (err: any) {
      toast({ title: 'Erro ao atualizar', description: err.message, variant: 'destructive' });
    }
    setIsSaving(false);
  };

  // Dialog de edição removido pois não há edição para inspection_reports

  // Buscar nomes dos assigned - REMOVIDO PARA EVITAR LOOPS
  // Será feito via query separada se necessário

  // Buscar activities - REMOVIDO PARA EVITAR LOOPS
  // Será feito via query separada se necessário

  // Buscar nomes dos gestores - REMOVIDO PARA EVITAR LOOPS
  // Será feito via query separada se necessário

  // [CORRIGIR] Montar lista de checklist para edição
  const reportChecklistMap = (() => {
    if (!editReportId || !reportToEdit || !Array.isArray(allChecklistItems) || allChecklistItems.length === 0) {
      return [];
    }
    
    // Obter o id da classe do usuário responsável pelo relatório
    const userClassId = reportToEdit.technician?.user_class?.id;
    
    if (!userClassId) {
      return [];
    }
    
    // Filtrar apenas itens da classe do usuário
    const filteredItems = allChecklistItems.filter(item => String(item.user_class_id) === String(userClassId));
    
    return filteredItems;
  })();

  // [ADICIONAR] Sincronizar editChecklist com os dados do relatório - REMOVIDO PARA EVITAR LOOPS
  // O checklist será sincronizado diretamente nos handlers

  // Mapa de números de relatório otimizado
  const reportNumbersMap = (() => {
    if (!reports || reports.length === 0) return {};
    
    const map: Record<string, string> = {};
    reports.forEach((report: any) => {
      if (report.report_number && report.report_number > 0) {
        map[report.id] = `REL-${report.report_number}`;
      } else {
        const shortId = report.id.replace(/-/g, '').slice(0, 8);
        map[report.id] = `REL-${shortId}`;
      }
    });
    return map;
  })();

  // Função para obter o número do relatório com prefixo REL-
  const getReportNumber = (report: any) => {
    const cachedNumber = reportNumbersMap[report.id];
    if (cachedNumber) {
      return cachedNumber;
    }
    
    // Fallback caso o mapa não tenha o relatório
    if (report.report_number && report.report_number > 0) {
      return `REL-${report.report_number}`;
    }
    
    const shortId = report.id.replace(/-/g, '').slice(0, 8);
    return `REL-${shortId}`;
  };

  // NOVO: Função para obter o código do relatório principal
  const getParentReportCode = (adequacaoReport: any) => {
    if (!adequacaoReport?.parentReport) return null;
    
    if (adequacaoReport.parentReport.report_number) {
      return `REL-${adequacaoReport.parentReport.report_number}`;
    }
    
    // Fallback para relatórios antigos
    const shortId = adequacaoReport.parentReport.id.replace(/-/g, '').slice(0, 8);
    return `REL-${shortId}`;
  };

  // Função para exportar CSV dos relatórios filtrados
  async function handleExportCsv() {
    const { startDate, endDate } = filters;
    if (!startDate || !endDate) {
      toast({ title: "Selecione as duas datas.", variant: "destructive" });
      return;
    }
    const start = new Date(startDate);
    const end = new Date(endDate);
    const diffTime = Math.abs(end.getTime() - start.getTime());
    const diffDays = diffTime / (1000 * 60 * 60 * 24);
    if (diffDays > 92) {
      toast({ title: "O intervalo máximo permitido é de 3 meses.", variant: "destructive" });
      return;
    }
    if (end < start) {
      toast({ title: "A data final deve ser maior que a inicial.", variant: "destructive" });
      return;
    }

    // Buscar TODOS os relatórios do período selecionado (sem paginação)
    try {
      let query = supabase
        .from('reports')
        .select(`
          id, title, description, status, created_at, updated_at, 
          numero_servico, pending_reason, pending_notes, assigned_to, 
          attachments, form_data, checklist_data, report_number, parent_report_id,
          validated_by, validated_at, technician_id, template_id
        `)
        .neq('template_id', '4b45c601-e5b7-4a33-98f9-1769aad319e9')
        .order('created_at', { ascending: false });

      // Aplicar filtros de data
      query = query.gte('created_at', startDate);
      query = query.lte('created_at', endDate + 'T23:59:59');

      // Aplicar outros filtros se definidos
      if (filters.technician && filters.technician !== 'all') {
        query = query.eq('technician_id', filters.technician);
      }
      if (filters.status && filters.status !== 'all') {
        query = query.eq('status', filters.status as any);
      }
      if (filters.serviceNumber && filters.serviceNumber.trim()) {
        query = query.ilike('numero_servico', `%${filters.serviceNumber.trim()}%`);
      }
      if (filters.reportNumber && filters.reportNumber.trim()) {
        const cleanReportNumber = filters.reportNumber.trim().replace(/^REL-?/i, '');
        if (cleanReportNumber) {
          query = query.eq('report_number', parseInt(cleanReportNumber));
        }
      }
      if (filters.dynamicField && filters.dynamicField.trim()) {
        const searchTerm = filters.dynamicField.trim();
        query = query.or(`title.ilike.%${searchTerm}%,description.ilike.%${searchTerm}%,numero_servico.ilike.%${searchTerm}%`);
      }
      if (filters.userClass && filters.userClass !== 'all') {
        const { data: techniciansFromClass } = await supabase
          .from('profiles')
          .select('id')
          .eq('user_class_id', filters.userClass)
          .eq('is_active', true);
        
        if (techniciansFromClass && techniciansFromClass.length > 0) {
          const technicianIds = techniciansFromClass.map(t => t.id);
          query = query.in('technician_id', technicianIds);
        } else {
          query = query.eq('technician_id', 'no-technicians-found');
        }
      }

      const { data: allReports, error } = await query;
      
      if (error) {
        console.error('❌ Erro ao buscar relatórios para exportação:', error);
        toast({ title: "Erro ao buscar relatórios.", description: error.message, variant: "destructive" });
        return;
      }

      if (!allReports || allReports.length === 0) {
        toast({ title: "Nenhum relatório encontrado no período selecionado.", variant: "destructive" });
        return;
      }

      // Buscar dados dos técnicos e templates para todos os relatórios
      const technicianIds = [...new Set(allReports.map((r: any) => r.technician_id).filter(Boolean))];
      const templateIds = [...new Set(allReports.map((r: any) => r.template_id).filter(Boolean))];
      
      let techniciansData: any[] = [];
      let templatesData: any[] = [];
      
      if (technicianIds.length > 0) {
        const { data: techData } = await supabase
          .from('profiles')
          .select('id, name, user_class:user_classes(id, name)')
          .in('id', technicianIds);
        techniciansData = techData || [];
      }
      
      if (templateIds.length > 0) {
        const { data: tempData } = await supabase
          .from('report_templates')
          .select('*')
          .in('id', templateIds);
        templatesData = tempData || [];
      }
      
      // Mapear dados para incluir relacionamentos
      const reportsWithRelations = allReports.map((report: any) => {
        const technician = techniciansData.find(t => t.id === report.technician_id);
        const template = templatesData.find(t => t.id === report.template_id);
        
        return {
          ...report,
          technician,
          template
        };
      });

      // Função para limpar e normalizar texto para CSV
      const cleanTextForCSV = (text: string): string => {
        if (!text) return '';
        
        return text
          .replace(/\r\n/g, ' ') // Substituir quebras de linha por espaço
          .replace(/\n/g, ' ')   // Substituir quebras de linha por espaço
          .replace(/\r/g, ' ')   // Substituir retornos por espaço
          .replace(/\t/g, ' ')   // Substituir tabs por espaço
          .replace(/\s+/g, ' ')  // Múltiplos espaços por um só
          .trim();               // Remover espaços no início e fim
      };

      // Função para extrair dados do form_data usando os labels dos campos
      const extractFormDataWithLabels = (formData: any, template: any) => {
        if (!formData) return {};
        
        let parsedFormData = formData;
        if (typeof formData === 'string') {
          try {
            parsedFormData = JSON.parse(formData);
          } catch {
            return {};
          }
        }
        
        const extracted: Record<string, any> = {};
        
        // Função auxiliar para processar valores
        const processValue = (value: any): string => {
          if (value === null || value === undefined) return '';
          if (typeof value === 'string') return cleanTextForCSV(value);
          if (typeof value === 'object' && value !== null) {
            if (value.url) return value.url;
            if (value.name) return value.name;
            if (value.id) return String(value.id);
            return JSON.stringify(value);
          }
          return String(value);
        };
        
        // Extrair campos usando os labels dos templates
        if (template?.fields && Array.isArray(template.fields)) {
          template.fields.forEach((field: any) => {
            const fieldKey = field.id || field.name;
            const fieldLabel = field.label || field.name;
            const value = parsedFormData[fieldKey];
            
            if (value !== undefined && value !== null) {
              if (typeof value === 'string') {
                extracted[fieldLabel] = cleanTextForCSV(value);
              } else if (Array.isArray(value)) {
                extracted[fieldLabel] = value.map(processValue).join('; ');
              } else if (typeof value === 'object' && value !== null) {
                extracted[fieldLabel] = processValue(value);
              } else {
                extracted[fieldLabel] = String(value);
              }
            } else {
              extracted[fieldLabel] = '';
            }
          });
        }
        
        // Extrair campos específicos que podem estar com nomes diferentes
        const specificFields = {
          'Data do Serviço': parsedFormData.data_servico || parsedFormData.data || parsedFormData.data_do_servico || '',
          'Endereço': parsedFormData.endereco || parsedFormData.address || parsedFormData.endereco_servico || '',
          'Bairro': parsedFormData.bairro || parsedFormData.neighborhood || parsedFormData.bairro_servico || '',
          'Cidade': parsedFormData.cidade || parsedFormData.city || parsedFormData.cidade_servico || '',
          'Serviço Finalizado?': parsedFormData.servico_finalizado || parsedFormData.finalizado || parsedFormData.concluido || '',
          'Observações': parsedFormData.observacoes || parsedFormData.observations || parsedFormData.obs || ''
        };
        
        // Adicionar campos específicos apenas se não estiverem vazios
        Object.entries(specificFields).forEach(([label, value]) => {
          if (value && value !== '') {
            extracted[label] = cleanTextForCSV(String(value));
          }
        });
        
        // Extrair todos os outros campos do form_data que não foram capturados pelos templates
        Object.keys(parsedFormData).forEach(key => {
          const value = parsedFormData[key];
          if (value !== undefined && value !== null) {
            // Verificar se o campo já foi processado
            const existingField = Object.values(extracted).find(v => v === cleanTextForCSV(String(value)));
            if (!existingField) {
              // Usar o nome do campo como label se não foi processado
              const fieldLabel = key.charAt(0).toUpperCase() + key.slice(1).replace(/_/g, ' ');
              if (typeof value === 'string') {
                extracted[fieldLabel] = cleanTextForCSV(value);
              } else if (Array.isArray(value)) {
                extracted[fieldLabel] = value.map(processValue).join('; ');
              } else if (typeof value === 'object' && value !== null) {
                extracted[fieldLabel] = processValue(value);
              } else {
                extracted[fieldLabel] = String(value);
              }
            }
          }
        });
        
        return extracted;
      };

      // Mapeia para criar uma estrutura mais organizada para CSV
      const exportData = reportsWithRelations.map((report: any) => {
        const { form_data, checklist_data, attachments } = report;
        
        // Extrair dados do form_data usando labels
        const formDataExtracted = extractFormDataWithLabels(form_data, report.template);
        
        // Processar checklist_data se existir
        let checklistInfo = '';
        if (checklist_data) {
          try {
            const checklist = typeof checklist_data === 'string' ? JSON.parse(checklist_data) : checklist_data;
            if (Array.isArray(checklist)) {
              checklistInfo = checklist.map((item: any) => {
                if (typeof item === 'object' && item !== null) {
                  return `${item.name || item.material || item.id}: ${item.quantity || 0}`;
                }
                return String(item);
              }).join('; ');
            }
          } catch (e) {
            checklistInfo = 'Erro ao processar checklist';
          }
        }
        
        // Processar attachments se existir
        let attachmentsInfo = '';
        if (attachments) {
          try {
            const atts = typeof attachments === 'string' ? JSON.parse(attachments) : attachments;
            if (Array.isArray(atts)) {
              attachmentsInfo = atts.map((att: any) => {
                if (typeof att === 'object' && att !== null) {
                  return att.url || att.name || 'arquivo';
                }
                return String(att);
              }).join('; ');
            }
          } catch (e) {
            attachmentsInfo = 'Erro ao processar anexos';
          }
        }
        
        // Definir ordem fixa das colunas
        return {
          'Código Único': getReportNumber(report),
          'ID do Relatório': report.id || '',
          'Número do Serviço': report.numero_servico || '',
          'Título': cleanTextForCSV(report.title || ''),
          'FCA': cleanTextForCSV(report.description || ''),
          'Status': report.status || '',
          'Técnico': report.technician?.name || '',
          'Data de Criação': report.created_at ? new Date(report.created_at).toLocaleDateString('pt-BR') : '',
          'Data de Atualização': report.updated_at ? new Date(report.updated_at).toLocaleDateString('pt-BR') : '',
          'Validado em': report.validated_at ? new Date(report.validated_at).toLocaleDateString('pt-BR') : '',
          'Validado por': report.validated_by || '',
          'ID da Ordem de Serviço': report.service_order_id || '',
          'Atribuído para': report.assigned_to || '',
          'Motivo da Pendência': cleanTextForCSV(report.pending_reason || ''),
          'Observações da Pendência': cleanTextForCSV(report.pending_notes || ''),
          'ID do Relatório Pai': report.parent_report_id || '',
          'Informações do Checklist': checklistInfo,
          'Anexos': attachmentsInfo,
          // Incluir campos dinâmicos do formulário em ordem alfabética
          ...Object.keys(formDataExtracted)
            .sort()
            .reduce((acc, key) => {
              acc[key] = formDataExtracted[key];
              return acc;
            }, {} as Record<string, any>)
        };
      });
      
      exportToCSV(exportData, `relatorios_validacao_${startDate}_a_${endDate}`);
      
    } catch (error) {
      console.error('❌ Erro ao exportar CSV:', error);
      toast({ title: "Erro ao exportar CSV.", description: "Tente novamente.", variant: "destructive" });
    }
  }

  // Função para exportar CSV dos itens do checklist (um por linha)
  async function handleExportCsvChecklist() {
    const { startDate, endDate } = filters;
    if (!startDate || !endDate) {
      toast({ title: "Selecione as duas datas.", variant: "destructive" });
      return;
    }
    const start = new Date(startDate);
    const end = new Date(endDate);
    const diffTime = Math.abs(end.getTime() - start.getTime());
    const diffDays = diffTime / (1000 * 60 * 60 * 24);
    if (diffDays > 92) {
      toast({ title: "O intervalo máximo permitido é de 3 meses.", variant: "destructive" });
      return;
    }
    if (end < start) {
      toast({ title: "A data final deve ser maior que a inicial.", variant: "destructive" });
      return;
    }

    try {
      // Buscar TODOS os relatórios do período selecionado (sem paginação)
      let query = supabase
        .from('reports')
        .select(`
          id, title, description, status, created_at, updated_at, 
          numero_servico, pending_reason, pending_notes, assigned_to, 
          attachments, form_data, checklist_data, report_number, parent_report_id,
          validated_by, validated_at, technician_id, template_id
        `)
        .neq('template_id', '4b45c601-e5b7-4a33-98f9-1769aad319e9')
        .order('created_at', { ascending: false });

      // Aplicar filtros de data
      query = query.gte('created_at', startDate);
      query = query.lte('created_at', endDate + 'T23:59:59');

      // Aplicar outros filtros se definidos
      if (filters.technician && filters.technician !== 'all') {
        query = query.eq('technician_id', filters.technician);
      }
      if (filters.status && filters.status !== 'all') {
        query = query.eq('status', filters.status as any);
      }
      if (filters.serviceNumber && filters.serviceNumber.trim()) {
        query = query.ilike('numero_servico', `%${filters.serviceNumber.trim()}%`);
      }
      if (filters.reportNumber && filters.reportNumber.trim()) {
        const cleanReportNumber = filters.reportNumber.trim().replace(/^REL-?/i, '');
        if (cleanReportNumber) {
          query = query.eq('report_number', parseInt(cleanReportNumber));
        }
      }
      if (filters.dynamicField && filters.dynamicField.trim()) {
        const searchTerm = filters.dynamicField.trim();
        query = query.or(`title.ilike.%${searchTerm}%,description.ilike.%${searchTerm}%,numero_servico.ilike.%${searchTerm}%`);
      }
      if (filters.userClass && filters.userClass !== 'all') {
        const { data: techniciansFromClass } = await supabase
          .from('profiles')
          .select('id')
          .eq('user_class_id', filters.userClass)
          .eq('is_active', true);
        
        if (techniciansFromClass && techniciansFromClass.length > 0) {
          const technicianIds = techniciansFromClass.map(t => t.id);
          query = query.in('technician_id', technicianIds);
        } else {
          query = query.eq('technician_id', 'no-technicians-found');
        }
      }

      const { data: allReports, error } = await query;
      
      if (error) {
        console.error('❌ Erro ao buscar relatórios para exportação de checklist:', error);
        toast({ title: "Erro ao buscar relatórios.", description: error.message, variant: "destructive" });
        return;
      }

      if (!allReports || allReports.length === 0) {
        toast({ title: "Nenhum relatório encontrado no período selecionado.", variant: "destructive" });
        return;
      }

      // Buscar dados dos técnicos para todos os relatórios
      const technicianIds = [...new Set(allReports.map((r: any) => r.technician_id).filter(Boolean))];
      
      let techniciansData: any[] = [];
      if (technicianIds.length > 0) {
        const { data: techData } = await supabase
          .from('profiles')
          .select('id, name')
          .in('id', technicianIds);
        techniciansData = techData || [];
      }
      
      // Mapear dados para incluir relacionamentos
      const reportsWithRelations = allReports.map((report: any) => {
        const technician = techniciansData.find(t => t.id === report.technician_id);
        
        return {
          ...report,
          technician
        };
      });

      // Buscar todos os itens do checklist para todos os relatórios
      const reportIds = reportsWithRelations.map((r: any) => r.id);
      
      // Buscar todos os report_checklist_items
      const { data: checklistLinks, error: errorLinks } = await supabase
        .from('report_checklist_items')
        .select('report_id, checklist_item_id, quantity, notes')
        .in('report_id', reportIds);
      
      if (errorLinks) {
        console.error('❌ Erro ao buscar itens do checklist:', errorLinks);
        toast({ title: "Erro ao buscar itens do checklist.", description: errorLinks.message, variant: "destructive" });
        return;
      }

      const checklistItemIds = [...new Set((checklistLinks || []).map((item: any) => item.checklist_item_id))];
      
      // Buscar todos os checklist_items necessários
      const { data: checklistItems, error: errorItems } = await supabase
        .from('checklist_items')
        .select('id, name, category, standard_quantity')
        .in('id', checklistItemIds);
      
      if (errorItems) {
        console.error('❌ Erro ao buscar dados dos itens do checklist:', errorItems);
        toast({ title: "Erro ao buscar dados dos itens do checklist.", description: errorItems.message, variant: "destructive" });
        return;
      }

      const checklistItemMap: Record<string, any> = {};
      (checklistItems || []).forEach((item: any) => { 
        checklistItemMap[item.id] = item; 
      });

      // Montar linhas do CSV: uma por item do checklist de cada relatório
      const checklistRows: any[] = [];
      
      reportsWithRelations.forEach((report: any) => {
        // Buscar itens do checklist para este relatório
        const reportChecklistItems = (checklistLinks || []).filter((item: any) => item.report_id === report.id);
        
        reportChecklistItems.forEach((item: any) => {
          const checklistItem = checklistItemMap[item.checklist_item_id];
          checklistRows.push({
            codigo_unico: getReportNumber(report),
            id_relatorio: report.id,
            numero_servico: report.numero_servico,
            tecnico_nome: report.technician?.name || "",
            material_servico: checklistItem?.name || item.checklist_item_id,
            quantidade: item.quantity ?? "",
            tipo: checklistItem?.category ?? ""
          });
        });
      });

      if (checklistRows.length === 0) {
        toast({ title: "Nenhum material/serviço encontrado no período selecionado.", variant: "destructive" });
        return;
      }
      
      exportToCSV(checklistRows, `relatorios_checklist_${startDate}_a_${endDate}`);
      
    } catch (error) {
      console.error('❌ Erro ao exportar CSV do checklist:', error);
      toast({ title: "Erro ao exportar CSV do checklist.", description: "Tente novamente.", variant: "destructive" });
    }
  }



  if (isLoading) {
    return (
      <div className="min-h-screen bg-gradient-to-br from-gray-50 to-gray-100">
        <div className="flex items-center justify-center min-h-screen">
          <LoadingSpinner text="Carregando relatórios..." />
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gradient-to-br from-gray-50 to-gray-100">
      {/* Header */}
      <header className="bg-white shadow-sm border-b">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="flex justify-between items-center py-4">
            <div className="flex items-center space-x-4">
              <div className="w-10 h-10 bg-primary rounded-lg flex items-center justify-center">
                <FileText className="w-6 h-6 text-white" />
              </div>
              <div>
                <h1 className="text-2xl font-bold text-gray-900">Validação de Relatórios Técnicos</h1>
                <p className="text-sm text-gray-600">Valide e gerencie relatórios enviados pelos técnicos</p>
              </div>
            </div>
          </div>
        </div>
      </header>

      {/* Main Content */}
      <main className="max-w-7xl mx-auto px-2 sm:px-4 lg:px-8 py-4 sm:py-8 space-y-6">
        
        {/* Filtros */}
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center space-x-2">
              <Filter className="w-5 h-5" />
              <span>Filtros</span>
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="flex flex-col gap-4">
              {/* Primeira linha de filtros */}
              <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
                <div>
                  <label className="text-sm font-medium text-gray-700 mb-2 block">Técnico</label>
                  <Select 
                    value={filters.technician} 
                    onValueChange={(value) => setFilters(prev => ({...prev, technician: value}))}
                  >
                    <SelectTrigger className="w-full" >
                      <SelectValue placeholder="Técnico" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="all">Todos</SelectItem>
                      {technicians.map((tech) => (
                        <SelectItem key={tech.id} value={tech.id}>
                          {tech.name}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                </div>

                <div>
                  <label className="text-sm font-medium text-gray-700 mb-2 block">Status</label>
                  <Select 
                    value={filters.status} 
                    onValueChange={(value) => setFilters(prev => ({...prev, status: value}))}
                  >
                    <SelectTrigger>
                      <SelectValue placeholder="Status" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="all">Todos</SelectItem>
                      <SelectItem value="nao_validado">Não Validado</SelectItem>
                      <SelectItem value="validado">Validado</SelectItem>
                      <SelectItem value="pendente">Pendente</SelectItem>
                      <SelectItem value="em_adequacao">Em adequação</SelectItem>
                      <SelectItem value="adequado">Adequado</SelectItem>
                      <SelectItem value="sem_pendencia">Sem pendência</SelectItem>
                      <SelectItem value="faturado">Faturado</SelectItem>
                    </SelectContent>
                  </Select>
                </div>

                <div>
                  <label className="text-sm font-medium text-gray-700 mb-2 block">Número do Serviço</label>
                  <Input
                    placeholder="Número"
                    value={serviceNumberInput}
                    onChange={(e) => setServiceNumberInput(e.target.value)}
                  />
                </div>

                <div>
                  <label className="text-sm font-medium text-gray-700 mb-2 block">Código do Relatório</label>
                  <Input
                    placeholder="REL-607"
                    value={reportNumberInput}
                    onChange={(e) => setReportNumberInput(e.target.value)}
                  />
                </div>
              </div>

              {/* Segunda linha de filtros */}
              <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
                <div>
                  <label className="text-sm font-medium text-gray-700 mb-2 block">Classe</label>
                  <Select 
                    value={filters.userClass} 
                    onValueChange={(value) => setFilters(prev => ({...prev, userClass: value}))}
                  >
                    <SelectTrigger>
                      <SelectValue placeholder="Classe" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="all">Todas</SelectItem>
                      {userClasses.map((userClass) => (
                        <SelectItem key={userClass.id} value={userClass.id}>
                          {userClass.name}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                </div>

                <div>
                  <label className="text-sm font-medium text-gray-700 mb-2 block">Data Inicial</label>
                  <Input
                    type="date"
                    value={filters.startDate}
                    onChange={(e) => setFilters(prev => ({...prev, startDate: e.target.value}))}
                  />
                </div>

                <div>
                  <label className="text-sm font-medium text-gray-700 mb-2 block">Data Final</label>
                  <Input
                    type="date"
                    value={filters.endDate}
                    onChange={(e) => setFilters(prev => ({...prev, endDate: e.target.value}))}
                  />
                </div>

                <div>
                  <label className="text-sm font-medium text-gray-700 mb-2 block">Informações Gerais</label>
                  <Input
                    placeholder="Endereço, cidade, etc..."
                    value={dynamicFieldInput}
                    onChange={(e) => setDynamicFieldInput(e.target.value)}
                  />
                </div>
              </div>
              <div className="flex justify-end gap-2">
                <Button onClick={handleExportCsv} variant="default">
                  <FileText className="h-4 w-4 mr-2" />
                  Exportar CSV
                </Button>
                <Button onClick={handleExportCsvChecklist} variant="outline">
                  <FileText className="h-4 w-4 mr-2" />
                  Exportar CSV Checklist
                </Button>
              </div>
            </div>
          </CardContent>
        </Card>

        {/* Lista de Relatórios */}
        <div className="space-y-4">
          {reports
            .filter(report => report && typeof report === 'object' && 'id' in report && report.id)
            .map((report) => {
              const isFaturado = typeof report.status === 'string' && report.status === 'faturado';
              const adequacaoReport = reports.find(r =>
                r.service_order_id === report.service_order_id &&
                r.technician_id === report.assigned_to &&
                r.id !== report.id
              );
              // NOVA LÓGICA: Verificar se já foi validado usando os campos validated_by e validated_at
              const hasBeenValidated = report.validated_by && report.validated_at;
              // Verificar se já foi adequado em algum momento (manter lógica atual para compatibilidade)
              const hasBeenAdequado = Array.isArray(activities[report.id]) && activities[report.id].some(a => a.action === "em_adequacao");

              return (
                <Card key={report.id} className="shadow-sm break-words">
                  <Collapsible open={expandedCards.has(report.id)} onOpenChange={() => toggleCardExpansion(report.id)}>
                    <CollapsibleTrigger className="w-full">
                      <CardHeader className="cursor-pointer hover:bg-gray-50 transition-colors">
                        <div className="flex items-center justify-between">
                          <div className="flex flex-col items-start gap-1">
                                                          <div className="flex items-center gap-2">
                                <span className="font-mono font-medium text-primary">
                                  {getReportNumber(report)}
                                </span>
                              <span className="text-lg font-semibold">
                                Nº do Serviço: {report.numero_servico || 'N/A'} | Enviado por: {report.technician?.name || 'N/A'}
                              </span>
                            <Badge className={getStatusColor(report.status)}>
                              {getStatusLabel(report.status)}
                            </Badge>
                            </div>
                          </div>
                          <div className="flex items-center gap-2">
                            <span className="text-sm text-gray-500">
                              {new Date(report.created_at).toLocaleDateString('pt-BR')}
                            </span>
                            {expandedCards.has(report.id) ? <ChevronDown className="w-4 h-4" /> : <ChevronRight className="w-4 h-4" />}
                          </div>
                        </div>
                      </CardHeader>
                    </CollapsibleTrigger>

                    <CollapsibleContent>
                      <CardContent className="pt-0">
                        <div className="space-y-6">
                          {/* Informações do Relatório */}
                          <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                            <div>
                              <h4 className="font-semibold text-gray-900 mb-2">Informações Gerais</h4>
                              <div className="space-y-2 text-sm break-words whitespace-normal">
                                <div><span className="font-medium">Número do Serviço:</span> {report.numero_servico || 'N/A'}</div>
                                <div><span className="font-medium">Título:</span> {report.title}</div>
                                <div><span className="font-medium">FCA:</span> {report.description}</div>
                                <div><span className="font-medium">Gestor:</span> {report.manager?.name || managerNames[report.manager_id] || '-'}</div>
                                <div><span className="font-medium">Tipo de Manutenção:</span> N/A</div>
                                {(() => {
                                  const adequacaoActivity = activities[report.id]?.find(a => a.action === "em_adequacao");
                                  if (adequacaoActivity && adequacaoActivity.details?.assignedTo) {
                                    return (
                                      <div className="mt-2">
                                        <span className="font-medium">Adequação por:</span> {assignedNames[adequacaoActivity.details.assignedTo] || adequacaoActivity.details.assignedTo}
                                      </div>
                                    );
                                  }
                                  return null;
                                })()}
                              </div>
                            </div>

                            <div>
                              <h4 className="font-semibold text-gray-900 mb-2">Datas</h4>
                              <div className="space-y-2 text-sm">
                                <div><span className="font-medium">Criado em:</span> {new Date(report.created_at).toLocaleString('pt-BR')}</div>
                                <div><span className="font-medium">Atualizado em:</span> {new Date(report.updated_at).toLocaleString('pt-BR')}</div>
                                {report.validated_at && (
                                  <div><span className="font-medium">Validado em:</span> {new Date(report.validated_at).toLocaleString('pt-BR')}</div>
                                )}
                              </div>
                            </div>
                          </div>

                          {/* Exibir campos dinâmicos do formulário */}
                          {report.form_data && Array.isArray(report.template?.fields) && report.template.fields.length > 0 && (
                            <div className="mt-4">
                              <h4 className="font-semibold text-gray-900 mb-2">Campos do Formulário</h4>
                              <div className="space-y-2 text-sm">
                                {report.template.fields.map((field: any, idx: number) => (
                                  <div key={idx}>
                                    <span className="font-medium">{field.label || field.name}:</span>{' '}
                                    {Array.isArray(report.form_data[field.id || field.name])
                                      ? report.form_data[field.id || field.name].join(', ')
                                      : String(report.form_data[field.id || field.name] ?? '-')}
                                  </div>
                                ))}
                              </div>
                            </div>
                          )}

                          {/* Anexos/Fotos */}
                          {Array.isArray(report.attachments) && report.attachments.length > 0 && (
                            <div>
                              <h4 className="font-semibold text-gray-900 mb-2">Anexos</h4>
                              <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-3">
                                {report.attachments.map((attachment: any, index) => (
                                  <div key={index} className="relative">
                                    <Dialog>
                                      <DialogTrigger asChild>
                                        <div className="relative cursor-pointer group">
                                          <div className="w-full aspect-square rounded-xl bg-gradient-to-br from-gray-50 to-gray-100 overflow-hidden shadow-sm hover:shadow-md transition-all duration-300 group-hover:scale-105 border border-gray-200">
                                            <img
                                              src={attachment?.url || ''}
                                              alt={`Anexo ${index + 1}`}
                                              className="w-full h-full object-cover transition-all duration-300 group-hover:brightness-110"
                                              onError={(e) => {
                                                const target = e.target as HTMLImageElement;
                                                target.style.display = 'none';
                                                target.nextElementSibling?.classList.remove('hidden');
                                              }}
                                            />
                                            <div className="absolute inset-0 bg-black bg-opacity-0 group-hover:bg-opacity-10 transition-all duration-300 rounded-xl"></div>
                                          </div>
                                          <div className="absolute inset-0 bg-gray-100 flex items-center justify-center rounded-xl hidden">
                                            <span className="text-xs text-gray-500">Erro ao carregar</span>
                                          </div>
                                        </div>
                                      </DialogTrigger>
                                      <DialogContent className="max-w-4xl max-h-none p-0 overflow-hidden">
                                        <DialogHeader className="absolute top-4 left-4 z-10">
                                          <DialogTitle className="text-white text-lg">Visualizar Imagem</DialogTitle>
                                          <DialogDescription className="text-white text-sm">
                                            Clique no X para fechar
                                          </DialogDescription>
                                        </DialogHeader>
                                        <div className="relative h-full">
                                          <div className="absolute top-4 right-4 z-10">
                                            <Button
                                              variant="ghost"
                                              size="sm"
                                              onClick={() => document.querySelector('[data-radix-dialog-close]')?.dispatchEvent(new Event('click'))}
                                              className="text-white hover:bg-white hover:text-black"
                                            >
                                              <X className="w-4 h-4" />
                                            </Button>
                                          </div>
                                          
                                          <div className="h-full max-h-[80vh] flex items-center justify-center overflow-y-auto overflow-x-hidden">
                                            <img
                                              src={attachment?.url || ''}
                                              alt={`Anexo ${index + 1}`}
                                              className="w-auto h-auto max-w-full object-contain"
                                            />
                                          </div>
                                        </div>
                                      </DialogContent>
                                    </Dialog>
                                  </div>
                                ))}
                              </div>
                            </div>
                          )}

                          {/* Checklist */}
                          {expandedCards.has(report.id) && (
                            <div className="mt-4">
                              <h4 className="font-semibold text-gray-900 mb-2">Checklist</h4>
                              {Array.isArray(checklistItemsByReport[report.id]) && checklistItemsByReport[report.id].length > 0 ? (
                                <ul className="space-y-1 text-sm">
                                  {checklistItemsByReport[report.id].map((item, idx) => (
                                    <li key={idx} className="flex items-center gap-2">
                                      <span className="font-medium">{item.name}</span>
                                      <span className="text-gray-500">Qtd: {item.quantity}</span>
                                      {item.notes && <span className="text-gray-400 ml-2">Obs: {item.notes}</span>}
                                    </li>
                                  ))}
                                </ul>
                              ) : (
                                <div className="text-sm text-gray-500">Nenhum item de checklist registrado.</div>
                              )}
                            </div>
                          )}

                          {/* Botão para ver relatório de adequação */}
                          {(() => {
                            const adequacaoReport = adequacaoReports[report.id];
                            if (!adequacaoReport) return null;
                            return (
                              <Dialog>
                                <DialogTrigger asChild>
                                  <Button className="bg-blue-500 hover:bg-blue-600 text-white mt-2">
                                    <FileText className="w-4 h-4 mr-2" />
                                    Ver relatório de adequação
                                  </Button>
                                </DialogTrigger>
                                <DialogContent className="max-w-2xl max-h-[90vh] overflow-y-auto">
                                  <DialogHeader>
                                    <DialogTitle>Relatório de Adequação</DialogTitle>
                                  </DialogHeader>
                                  <div className="space-y-2">
                                    {/* NOVO: Exibir código do relatório principal */}
                                    {adequacaoReport.parentReport && (
                                      <div className="bg-blue-50 border border-blue-200 rounded-lg p-3 mb-3">
                                        <div className="text-sm font-medium text-blue-800">
                                          <strong>Relatório principal vinculado:</strong> {getParentReportCode(adequacaoReport)}
                                        </div>
                                      </div>
                                    )}
                                    <div><b>Título:</b> {adequacaoReport.title}</div>
                                    <div><b>FCA:</b> {adequacaoReport.description}</div>
                                    <div><b>Status:</b> {getStatusLabel(adequacaoReport.status)}</div>
                                    <div><b>Criado em:</b> {new Date(adequacaoReport.created_at).toLocaleString('pt-BR')}</div>
                                    {/* Campos do Formulário */}
                                    {adequacaoReport.form_data && Array.isArray(adequacaoReport.template?.fields) && adequacaoReport.template.fields.length > 0 && (
                                      <div className="mt-4">
                                        <h4 className="font-semibold text-gray-900 mb-2">Campos do Formulário</h4>
                                        <div className="space-y-2 text-sm">
                                          {adequacaoReport.template.fields.map((field: any, idx: number) => (
                                            <div key={idx}>
                                              <span className="font-medium">{field.label || field.name}:</span>{' '}
                                              {Array.isArray(adequacaoReport.form_data[field.id || field.name])
                                                ? adequacaoReport.form_data[field.id || field.name].join(', ')
                                                : String(adequacaoReport.form_data[field.id || field.name] ?? '-')}
                                            </div>
                                          ))}
                                        </div>
                                      </div>
                                    )}
                                    {/* Anexos */}
                                    {Array.isArray(adequacaoReport.attachments) && adequacaoReport.attachments.length > 0 && (
                                      <div>
                                        <b>Anexos:</b>
                                        <div className="grid grid-cols-2 md:grid-cols-4 gap-4 mt-2">
                                          {adequacaoReport.attachments.map((attachment: any, idx: number) => (
                                            <a key={idx} href={attachment.url} target="_blank" rel="noopener noreferrer">
                                              <img src={attachment.url} alt={attachment.name || `Anexo ${idx + 1}`} className="w-full h-24 object-cover rounded" />
                                            </a>
                                          ))}
                                        </div>
                                      </div>
                                    )}
                                    {/* Checklist da adequação */}
                                    {Array.isArray(adequacaoReport.checklist_data) && adequacaoReport.checklist_data.length > 0 && (
                                      <div>
                                        <b>Checklist:</b>
                                        <ul className="space-y-1 text-sm mt-1">
                                          {adequacaoReport.checklist_data.map((item: any, idx: number) => (
                                            <li key={idx} className="flex items-center gap-2">
                                              <span className="font-medium">{item.name || item.checklist_item_id}</span>
                                              {item.quantity && <span className="text-gray-500">Qtd: {item.quantity}</span>}
                                              {item.notes && <span className="text-gray-400 ml-2">Obs: {item.notes}</span>}
                                            </li>
                                          ))}
                                        </ul>
                                      </div>
                                    )}
                                  </div>
                                </DialogContent>
                              </Dialog>
                            );
                          })()}

                          {/* Após o checklist, exibir motivo e observação da pendência, se existirem */}
                          {report.pending_reason && (
                            <div className="mt-2">
                              <span className="font-semibold">Motivo da Pendência:</span> {report.pending_reason}
                            </div>
                          )}
                          {report.pending_notes && (
                            <div className="mt-1">
                              <span className="font-semibold">Observação:</span> {report.pending_notes}
                            </div>
                          )}

                          {/* Botões de Ação */}
                          <div className="flex flex-wrap gap-2 pt-4 border-t">
                            <Button
                              onClick={() => handleStatusUpdate(report.id, 'validado')}
                              className="bg-green-500 hover:bg-green-600 text-white"
                              disabled={updateStatusMutation.isPending || isFaturado || hasBeenValidated}
                            >
                              <CheckCircle className="w-4 h-4 mr-2" />
                              Validar
                            </Button>

                            <Dialog>
                              <DialogTrigger asChild>
                                <Button className="bg-pink-500 hover:bg-pink-600 text-white" disabled={isFaturado || !hasBeenValidated || hasBeenAdequado}>
                                  <AlertTriangle className="w-4 h-4 mr-2" />
                                  Adequar
                                </Button>
                              </DialogTrigger>
                              <DialogContent>
                                <DialogHeader>
                                  <DialogTitle>Direcionar para Adequação</DialogTitle>
                                </DialogHeader>
                                <div className="space-y-4">
                                  <div>
                                    <label className="block text-sm font-medium text-gray-700 mb-2">
                                      Selecione o Técnico
                                    </label>
                                    <Select value={selectedTechnician} onValueChange={setSelectedTechnician}>
                                      <SelectTrigger>
                                        <SelectValue placeholder="Selecione um técnico" />
                                      </SelectTrigger>
                                      <SelectContent>
                                        {technicians.map((tech) => (
                                          <SelectItem key={tech.id} value={tech.id}>
                                            {tech.name}
                                          </SelectItem>
                                        ))}
                                      </SelectContent>
                                    </Select>
                                  </div>
                                  <Button
                                    onClick={() => {
                                      handleStatusUpdate(report.id, 'em_adequacao', selectedTechnician);
                                    }}
                                    className="w-full"
                                  >
                                    Direcionar Adequação
                                  </Button>
                                </div>
                              </DialogContent>
                            </Dialog>

                            <Button
                              variant="outline"
                              className="border-purple-500 text-purple-500 hover:bg-purple-50"
                              onClick={() => handleOpenEditModal(report.id)}
                              disabled={isFaturado}
                            >
                              <Edit className="w-4 h-4 mr-2" />
                              Editar
                            </Button>

                            <Button
                              onClick={() => {
                                setPendingModalOpen(report.id);
                                setPendingReason('');
                                setPendingNotes('');
                              }}
                              className="bg-orange-500 hover:bg-orange-600 text-white"
                              disabled={updateStatusMutation.isPending || isFaturado || !hasBeenValidated}
                            >
                              <AlertTriangle className="w-4 h-4 mr-2" />
                              Pendenciar
                            </Button>

                            <Button
                              onClick={() => handleStatusUpdate(report.id, 'sem_pendencia')}
                              className="bg-emerald-600 hover:bg-emerald-700 text-white"
                              disabled={updateStatusMutation.isPending || isFaturado || String(report.status) === 'sem_pendencia' || !hasBeenValidated}
                            >
                              <CheckCircle className="w-4 h-4 mr-2" />
                              Sem pendência
                            </Button>

                            <Button
                              onClick={() => handleStatusUpdate(report.id, 'faturado')}
                              className="bg-blue-500 hover:bg-blue-600 text-white"
                              disabled={updateStatusMutation.isPending || isFaturado || !hasBeenValidated}
                            >
                              <DollarSign className="w-4 h-4 mr-2" />
                              Faturar
                            </Button>

                            <Button
                              variant="destructive"
                              className="ml-auto"
                              onClick={() => handleDeleteReport(report.id)}
                              disabled={deleteReportMutation.isPending || isFaturado}
                            >
                              <Trash2 className="w-4 h-4 mr-2" />
                              Deletar
                            </Button>
                          </div>
                        </div>
                      </CardContent>
                    </CollapsibleContent>
                  </Collapsible>
                  <div className="flex flex-col sm:flex-row justify-end items-stretch sm:items-center pt-4 border-t gap-2">
                    <Sheet>
                      <SheetTrigger asChild>
                        <Button variant="outline" className="min-w-[44px] min-h-[44px] w-full sm:w-auto" onClick={() => fetchActivities(report.id)}>
                          <History className="w-4 h-4 mr-2" />
                          Histórico
                        </Button>
                      </SheetTrigger>
                      <SheetContent>
                        <SheetHeader>
                          <SheetTitle>Histórico do Relatório</SheetTitle>
                        </SheetHeader>
                        <div className="space-y-4 mt-6 max-h-[60vh] overflow-y-auto pr-2">
                          {loadingActivities[report.id] && <div>Carregando...</div>}
                          {activities[report.id] && activities[report.id].length === 0 && <div>Nenhuma atividade encontrada.</div>}
                          {activities[report.id] && activities[report.id].map((activity) => (
                            <div key={activity.id} className="border-l-2 border-blue-200 pl-4">
                              <div className="flex items-center space-x-2">
                                <span className="text-sm font-medium">{activity.action}</span>
                                <span className="text-xs text-gray-500">{new Date(activity.created_at).toLocaleString('pt-BR')}</span>
                                {activity.user_id && (
                                  <span className="text-xs text-gray-700 italic">{userNames[activity.user_id] || activity.user_id}</span>
                                )}
                              </div>
                              <div className="text-xs text-gray-600 space-y-1">
                                {activity.details?.title && (
                                  <div><b>Título:</b> {activity.details.title}</div>
                                )}
                                {activity.details?.description && (
                                  <div><b>Descrição:</b> {activity.details.description}</div>
                                )}
                                {activity.details?.form_data && typeof activity.details.form_data === 'object' && (
                                  <div>
                                    <b>Formulário:</b>
                                    <ul className="ml-4">
                                      {Object.entries(activity.details.form_data).map(([key, value], idx) => (
                                        <li key={idx}>
                                          <b>{key}:</b>{' '}
                                          {Array.isArray(value)
                                            ? value.map((v, i) =>
                                                v && v.url ? (
                                                  <span key={i}>
                                                    <a href={v.url} target="_blank" rel="noopener noreferrer">{v.name || v.url}</a>
                                                  </span>
                                                ) : (
                                                  <span key={i}>{JSON.stringify(v)}</span>
                                                )
                                              )
                                            : typeof value === 'object'
                                              ? JSON.stringify(value)
                                              : String(value)}
                                        </li>
                                      ))}
                                    </ul>
                                  </div>
                                )}
                                {activity.details?.checklist_data && Array.isArray(activity.details.checklist_data) && (
                                  <div>
                                    <b>Checklist:</b>
                                    <ul className="list-disc ml-4">
                                      {activity.details.checklist_data.map((item, idx) => (
                                        <li key={idx}>{item.name || item.id} {item.quantity ? `- Qtd: ${item.quantity}` : ''}</li>
                                      ))}
                                    </ul>
                                  </div>
                                )}
                                {activity.details?.attachments && Array.isArray(activity.details.attachments) && (
                                  <div>
                                    <b>Anexos:</b>
                                    <ul className="ml-4">
                                      {activity.details.attachments.map((att, idx) => (
                                        <li key={idx}>
                                          <a href={att.url} target="_blank" rel="noopener noreferrer">{att.name || att.url}</a>
                                        </li>
                                      ))}
                                    </ul>
                                  </div>
                                )}
                                {/* Outros campos relevantes podem ser adicionados aqui */}
                              </div>
                            </div>
                          ))}
                        </div>
                      </SheetContent>
                    </Sheet>
                  </div>
                </Card>
              );
            })}

          <div className="text-xs text-gray-500 text-center mt-2">
            Mostrando {reports.length} de {totalReports} relatórios
          </div>
        </div>
      </main>

      {/* Controles de Paginação */}
      {totalPages > 1 && (
        <div className="flex justify-center items-center space-x-4 py-4 bg-white border-t">
          <div className="flex items-center space-x-2">
            <Button
              variant="outline"
              size="sm"
              onClick={() => handlePageChange(currentPage - 1)}
              disabled={currentPage === 1}
            >
              Anterior
            </Button>
            
            <span className="text-sm text-gray-600">
              Página {currentPage} de {totalPages}
            </span>
            
            <Button
              variant="outline"
              size="sm"
              onClick={() => handlePageChange(currentPage + 1)}
              disabled={currentPage === totalPages}
            >
              Próxima
            </Button>
          </div>
          
          <div className="flex items-center space-x-2">
            <span className="text-sm text-gray-600">Itens por página:</span>
            <Select value={pageSize.toString()} onValueChange={(value) => handlePageSizeChange(Number(value))}>
              <SelectTrigger className="w-20">
                <SelectValue />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="10">10</SelectItem>
                <SelectItem value="20">20</SelectItem>
                <SelectItem value="50">50</SelectItem>
                <SelectItem value="100">100</SelectItem>
              </SelectContent>
            </Select>
          </div>
        </div>
      )}

      {/* Modal de edição de relatório */}
      {editReportId && (
        <Dialog open={!!editReportId} onOpenChange={() => setEditReportId(null)}>
          <DialogContent className="max-w-2xl max-h-[90vh] overflow-y-auto">
            <DialogHeader>
              <DialogTitle>Editar Relatório</DialogTitle>
            </DialogHeader>
            {reportToEdit ? (
              <form onSubmit={handleEditSubmit} className="space-y-4">
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">Título</label>
                  <Input value={editTitle} onChange={e => setEditTitle(e.target.value)} required />
                </div>
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">Descrição</label>
                  <Textarea value={editDescription} onChange={e => setEditDescription(e.target.value)} required />
                </div>
                {/* Campos dinâmicos */}
                {Array.isArray(template?.fields) && template.fields.length > 0 && (
                  <div>
                    <h4 className="font-semibold text-gray-900 mb-2">Campos do Formulário</h4>
                    <div className="space-y-2">
                                              {template.fields.map((field: any, idx: number) => (
                          <div key={idx}>
                            <label className="block text-sm font-medium text-gray-700 mb-1">
                              {field.label || field.name}
                              {field.required && <span className="text-red-500 ml-1">*</span>}
                            </label>
                            
                            {/* Campo de texto curto */}
                            {field.type === 'texto_curto' && (
                              <Input
                                value={editFormData[field.id || field.name] ?? ''}
                                onChange={e => handleEditFieldChange(field.id || field.name, e.target.value)}
                                placeholder={field.placeholder}
                                required={field.required}
                              />
                            )}
                            
                            {/* Campo de texto longo */}
                            {field.type === 'texto_longo' && (
                              <Textarea
                                value={editFormData[field.id || field.name] ?? ''}
                                onChange={e => handleEditFieldChange(field.id || field.name, e.target.value)}
                                placeholder={field.placeholder}
                                required={field.required}
                              />
                            )}
                            
                            {/* Campo de data */}
                            {field.type === 'data' && (
                              <Input
                                type="date"
                                value={editFormData[field.id || field.name] ?? ''}
                                onChange={e => handleEditFieldChange(field.id || field.name, e.target.value)}
                                required={field.required}
                              />
                            )}
                            
                            {/* Campo dropdown */}
                            {field.type === 'dropdown' && Array.isArray(field.options) && (
                              <Select
                                value={editFormData[field.id || field.name] ?? ''}
                                onValueChange={(value) => handleEditFieldChange(field.id || field.name, value)}
                              >
                                <SelectTrigger>
                                  <SelectValue placeholder="Selecione uma opção" />
                                </SelectTrigger>
                                <SelectContent>
                                  {field.options.map((option: string, i: number) => (
                                    <SelectItem key={i} value={option}>
                                      {option}
                                    </SelectItem>
                                  ))}
                                </SelectContent>
                              </Select>
                            )}
                            
                            {/* Campo de radio */}
                            {field.type === 'radio' && Array.isArray(field.options) && (
                              <div className="flex flex-col gap-1">
                                {field.options.map((option: string, i: number) => (
                                  <label key={i} className="flex items-center gap-2">
                                    <input
                                      type="radio"
                                      name={field.id || field.name}
                                      value={option}
                                      checked={editFormData[field.id || field.name] === option}
                                      onChange={() => handleEditFieldChange(field.id || field.name, option)}
                                      required={field.required}
                                    />
                                    {option}
                                  </label>
                                ))}
                              </div>
                            )}
                            
                            {/* Campo de checkbox */}
                            {field.type === 'checkbox' && Array.isArray(field.options) && (
                              <div className="flex flex-col gap-1">
                                {field.options.map((option: string, i: number) => (
                                  <label key={i} className="flex items-center gap-2">
                                    <input
                                      type="checkbox"
                                      name={field.id || field.name}
                                      value={option}
                                      checked={Array.isArray(editFormData[field.id || field.name]) && 
                                               editFormData[field.id || field.name].includes(option)}
                                      onChange={e => {
                                        const prev = Array.isArray(editFormData[field.id || field.name]) 
                                          ? editFormData[field.id || field.name] 
                                          : [];
                                        if (e.target.checked) {
                                          handleEditFieldChange(field.id || field.name, [...prev, option]);
                                        } else {
                                          handleEditFieldChange(field.id || field.name, prev.filter((v: any) => v !== option));
                                        }
                                      }}
                                    />
                                    {option}
                                  </label>
                                ))}
                              </div>
                            )}
                            
                            {/* Fallback para campos não reconhecidos (incluindo upload) */}
                            {!['texto_curto', 'texto_longo', 'data', 'dropdown', 'radio', 'checkbox'].includes(field.type) && (
                              <Input
                                value={editFormData[field.id || field.name] ?? ''}
                                onChange={e => handleEditFieldChange(field.id || field.name, e.target.value)}
                                placeholder={field.placeholder}
                              />
                            )}
                          </div>
                        ))}
                    </div>
                  </div>
                )}
                {/* Checklist */}
                {template?.checklist_enabled && (
                  <Card>
                    <CardHeader>
                      <CardTitle>Checklist</CardTitle>
                    </CardHeader>
                    <CardContent>
                      <div className="p-2 border rounded-lg bg-green-50 border-green-300">
                        <ChecklistFormSection
                          items={reportChecklistMap}
                          value={editChecklist}
                          onChange={handleEditChecklistChange}
                        />
                      </div>
                    </CardContent>
                  </Card>
                )}
                {/* Anexos */}
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">Anexos</label>
                  <div className="flex flex-wrap gap-2 mb-2">
                    {editAttachments.map((att, idx) => (
                      <div key={idx} className="relative">
                        <a href={att.url} target="_blank" rel="noopener noreferrer">
                          <img src={att.url} alt={att.name} className="w-24 h-24 object-cover rounded" />
                        </a>
                        <Button
                          type="button"
                          size="sm"
                          variant="destructive"
                          className="absolute top-1 right-1"
                          onClick={() => handleRemoveAttachment(idx)}
                        >
                          Remover
                        </Button>
                      </div>
                    ))}
                  </div>
                  <Input
                    type="file"
                    multiple
                    accept="image/*,application/pdf"
                    onChange={handleEditFileChange}
                  />
                  {editUploadError && <div className="text-red-500 text-sm mt-1">{editUploadError}</div>}
                </div>
                <div className="flex gap-2 justify-end">
                  <Button type="button" variant="outline" onClick={() => setEditReportId(null)} disabled={isSaving}>Cancelar</Button>
                  <Button type="submit" className="bg-green-600 text-white" disabled={isSaving}>{isSaving ? 'Salvando...' : 'Salvar'}</Button>
                </div>
              </form>
            ) : (
              <div className="text-gray-500">Relatório não encontrado.</div>
            )}
          </DialogContent>
        </Dialog>
      )}

      {/* Modal de pendência */}
      <Dialog open={!!pendingModalOpen} onOpenChange={() => setPendingModalOpen(null)}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Pendenciar Relatório</DialogTitle>
          </DialogHeader>
          <div className="space-y-4">
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">Motivo</label>
              <select
                className="border rounded px-2 py-1 w-full"
                value={pendingReason}
                onChange={e => setPendingReason(e.target.value)}
              >
                <option value="">Selecione...</option>
                {pendingOptions.map(opt => (
                  <option key={opt} value={opt}>{opt}</option>
                ))}
              </select>
            </div>
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">Observação</label>
              <Textarea
                value={pendingNotes}
                onChange={e => setPendingNotes(e.target.value)}
                placeholder="Descreva o motivo da pendência..."
              />
            </div>
            <div className="flex justify-end gap-2">
              <Button variant="outline" onClick={() => setPendingModalOpen(null)}>Cancelar</Button>
              <Button
                onClick={async () => {
                  if (!pendingModalOpen) return;
                  await updateStatusMutation.mutateAsync({
                    reportId: pendingModalOpen,
                    status: 'pendente',
                    pending_reason: pendingReason,
                    pending_notes: pendingNotes,
                  });
                  setPendingModalOpen(null);
                }}
                disabled={!pendingReason}
              >
                Confirmar Pendência
              </Button>
            </div>
          </div>
        </DialogContent>
      </Dialog>
    </div>
  );
};

export default ReportValidation;

